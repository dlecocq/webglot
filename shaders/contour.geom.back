;
}

void main() {

	float isovalue = 0;
	
	float x = gl_PositionIn[0].x;
	float y = gl_PositionIn[0].y;
	float xp = gl_PositionIn[1].x;
	float yp = gl_PositionIn[1].y;
	
	float atxy;
	float atxdxy;
	float atxdxydy;
	float atxydy;
	
	float midxy;
	float midxydy;
	float midyx;
	float midyxdx;

	int ct;

	atxy 			= function(x, y);
	atxdxy 		= function(xp, y);
	atxdxydy 	= function(xp, yp);
	atxydy 		= function(x, yp);

	/*
	midxy 		= (x * atxdxy 	- xp * atxy		) / (atxdxy 	- atxy	);
	midxydy 	= (x * atxdxydy - xp * atxydy	) / (atxdxydy - atxydy);
	midyx 		= (y * atxydy 	- yp * atxy		) / (atxydy 	- atxy	);
	midyxdx 	= (y * atxdxydy - yp * atxdxy	) / (atxdxydy - atxdxy);
	*/

	// Encoding the case as an integer
	ct = (int(atxy > isovalue) * 8) + (int(atxdxy > isovalue) * 4) + (int(atxdxydy > isovalue) * 2) + int(atxydy > isovalue);
	if (ct == 1 || ct == 14) {
		midxydy 	= (x * atxdxydy - xp * atxydy	) / (atxdxydy - atxydy);
		midyx 		= (y * atxydy 	- yp * atxy		) / (atxydy 	- atxy	);
		
		gl_Position = gl_ModelViewProjectionMatrix * vec4(midxydy, yp, 0.0, 1.0);
		EmitVertex();
		gl_Position = gl_ModelViewProjectionMatrix * vec4(x, midyx, 0.0, 1.0);
		EmitVertex();
	} else if (ct == 2 || ct == 13) {
		midxydy 	= (x * atxdxydy - xp * atxydy	) / (atxdxydy - atxydy);
		midyxdx 	= (y * atxdxydy - yp * atxdxy	) / (atxdxydy - atxdxy);
		
		gl_Position = gl_ModelViewProjectionMatrix * vec4(midxydy, yp, 0.0, 1.0);
		EmitVertex();
		gl_Position = gl_ModelViewProjectionMatrix * vec4(xp, midyxdx, 0.0, 1.0);
		EmitVertex();
	} else if (ct == 3 || ct == 12) {
		midyx 		= (y * atxydy 	- yp * atxy		) / (atxydy 	- atxy	);
		midyxdx 	= (y * atxdxydy - yp * atxdxy	) / (atxdxydy - atxdxy);
		
		gl_Position = gl_ModelViewProjectionMatrix * vec4(x, midyx, 0.0, 1.0);
		EmitVertex();
		gl_Position = gl_ModelViewProjectionMatrix * vec4(xp, midyxdx, 0.0, 1.0);
		EmitVertex();
	} else if (ct == 4 || ct == 11) {
		midxy 		= (x * atxdxy 	- xp * atxy		) / (atxdxy 	- atxy	);
		midyxdx 	= (y * atxdxydy - yp * atxdxy	) / (atxdxydy - atxdxy);
		
		gl_Position = gl_ModelViewProjectionMatrix * vec4(midxy, y, 0.0, 1.0);
		EmitVertex();
		gl_Position = gl_ModelViewProjectionMatrix * vec4(xp, midyxdx, 0.0, 1.0);
		EmitVertex();
	} else if (ct == 5 || ct == 10) {
		midyx 		= (y * atxydy 	- yp * atxy		) / (atxydy 	- atxy	);
		midxy 		= (x * atxdxy 	- xp * atxy		) / (atxdxy 	- atxy	);
		midxydy 	= (x * atxdxydy - xp * atxydy	) / (atxdxydy - atxydy);
		midyxdx 	= (y * atxdxydy - yp * atxdxy	) / (atxdxydy - atxdxy);
		
		/* This is the abiguous case, and so we'll sample at what it essentially the middle.
		 * Actually, what we do is to take the average of the interpolated x and y
		 * intercepts (with the edge of the square) and then evaluate the function
		 * there.  Based on whether it's above or below the isovalue, we'll make 
		 * an informed choice as to which case to render
		 */
		float value = function((midxy + midxydy) / 2.0, (midyx + midyxdx) / 2.0);
		/*
		 * ct == 5 and ct == 10 encapsulate both cases where opposite corners are either
		 * both above or both below the isovalue. One of the two ways to divvy up the 
		 * lines includes the interior as above the isovalue, and the other excludes
		 * it as being under.  However, because 5 is the converse situtation as 10,
		 * when it's 5, we'll just invert the value, and run the same test
		 */
		if (ct == 5) {
			value = -value;
		}
		
		if (value < isovalue) {			
			gl_Position = gl_ModelViewProjectionMatrix * vec4(x, midyx, 0.0, 1.0);
			EmitVertex();
			gl_Position = gl_ModelViewProjectionMatrix * vec4(midxy, y, 0.0, 1.0);
			EmitVertex();
			EndPrimitive();
			gl_Position = gl_ModelViewProjectionMatrix * vec4(midxydy, yp, 0.0, 1.0);
			EmitVertex();
			gl_Position = gl_ModelViewProjectionMatrix * vec4(xp, midyxdx, 0.0, 1.0);
			EmitVertex();
		} else {
			gl_Position = gl_ModelViewProjectionMatrix * vec4(x, midyx, 0.0, 1.0);
			EmitVertex();
			gl_Position = gl_ModelViewProjectionMatrix * vec4(midxydy, yp, 0.0, 1.0);
			EmitVertex();
			EndPrimitive();
			gl_Position = gl_ModelViewProjectionMatrix * vec4(midxy, y, 0.0, 1.0);
			EmitVertex();
			gl_Position = gl_ModelViewProjectionMatrix * vec4(xp, midyxdx, 0.0, 1.0);
			EmitVertex();
		}
	} else if (ct == 6 || ct == 9) {
		midxy 		= (x * atxdxy 	- xp * atxy		) / (atxdxy 	- atxy	);
		midxydy 	= (x * atxdxydy - xp * atxydy	) / (atxdxydy - atxydy);
		
		gl_Position = gl_ModelViewProjectionMatrix * vec4(midxy, y, 0.0, 1.0);
		EmitVertex();
		gl_Position = gl_ModelViewProjectionMatrix * vec4(midxydy, yp, 0.0, 1.0);
		EmitVertex();
	} else if (ct == 7 || ct == 8) {
		midyx 		= (y * atxydy 	- yp * atxy		) / (atxydy 	- atxy	);
		midxy 		= (x * atxdxy 	- xp * atxy		) / (atxdxy 	- atxy	);
		
		gl_Position = gl_ModelViewProjectionMatrix * vec4(x, midyx, 0.0, 1.0);
		EmitVertex();
		gl_Position = gl_ModelViewProjectionMatrix * vec4(midxy, y, 0.0, 1.0);
		EmitVertex();
	}
	EndPrimitive();
}
